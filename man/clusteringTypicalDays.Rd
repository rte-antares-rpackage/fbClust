% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ClusteringTypicalDays.R
\name{clusteringTypicalDays}
\alias{clusteringTypicalDays}
\title{Generate a set of flow-based typical days on one time period}
\usage{
clusteringTypicalDays(calendar, PLAN, VERT = NULL, hubDrop = list(NL =
  c("BE", "DE", "FR", "AT")), nbClustWeek = 1, nbClustWeekend = 1,
  hourWeight = rep(1, 24), idStart = 1, maxDomainSize = 20000,
  ponderate = FALSE)
}
\arguments{
\item{calendar}{\code{list}, vector of date for each period. Can be obtain with \link{getCalendar}}

\item{PLAN}{\code{data.table}, at least ram, Date, Period and two ptdf columns :
\itemize{
 \item ptdfAT : autrichian vertices
 \item ptdfBE : belgium vertices
 \item ptdfDE : german vertices
 \item ptdfFR : french vertices
 \item ram : line limits
 \item Date : date in format YYYY-MM-DD
 \item Period : hour in the day, between 1 and 24
}
PLAN is generated in this format with the function \link{getPreprocPlan}}

\item{VERT}{\code{data.table}, the same Date, Period and ptdf  we have
in PLAN. Default = NULL 
This parameter can be obtained with the function \link{getVertices}.}

\item{hubDrop}{\code{list}, list of hubs in the ptdf, with the ones which should
sustracted to the others as the names of the arrays which themself contain the ones which
be sustracted}

\item{nbClustWeek}{\code{numeric}, number of clusters for week period(working days). Defaut to 3}

\item{nbClustWeekend}{\code{numeric}, number of clusters for weekend period. Defaut to 1}

\item{hourWeight}{\code{numeric}, vector of 24 weights, one for each hour of the day. The clustering algorithm
will be more accurate for the flow-based domains of the hours with a relatively higher weight.}

\item{idStart}{\code{numeric}, first identifier of the returned typical days. Default value is 1}

\item{maxDomainSize}{\code{numeric} limit of domain size in each axis. The function will return an error if one domain
or more exceed these limits.}

\item{ponderate}{\code{logical} if TRUE, each angular sector have the same weight 
in the clustering metric. E.g. {BE and FR imports, DE and NL exports} is one sector.}
}
\description{
Run a clustering algorithm on the different classes of the calendar (\link{getCalendar})
Its principle is to create clusters by
gathering the most similar days of each class and to choose among them the best
representative: it will be a so-called typical day. The metric used to determine the similarity of two days is
a weighted sum of 24 hourly distances, meaning the distances between the domains of the two
days at the same hour.
}
\examples{

\dontrun{
library(data.table)
library(quadprog)
PLAN <- readRDS(system.file("testdata/plan_test2.rds", package = "fbClust"))
calendar <- list()
calendar$interSeasonWe <- c("2018-10-01", "2018-10-02")
calendar$interSeasonWd <- c("2018-10-03", "2018-10-04")
hubDrop <- list(NL = c("BE", "DE", "FR", "AT"))
hourWeight = rep(1, 24)
nbClustWeek <- 1
nbClustWeekend <- 1
maxDomainSize <- 20000
 clusteringTypicalDays(
 calendar = calendar, PLAN = PLAN, VERT = NULL, hubDrop = hubDrop,
 maxDomainSize = maxDomainSize, nbClustWeek = nbClustWeek, 
 nbClustWeekend = nbClustWeekend, hourWeight = hourWeight)

}

}
